import { readFile, writeFile } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { generateFOUCScript } from '@mks2508/shadcn-basecoat-theme-manager';
import { confirmChanges, type IFileChange } from './diff-preview.ts';
import type { IProjectInfo } from './project-detector.ts';

export type FOUCResult = 'injected' | 'already-present' | 'no-entry-point' | 'declined';

/**
 * Detect the leading whitespace of the line containing `position`.
 * @param text - Full file content.
 * @param position - Character index within the text.
 * @returns The whitespace prefix of that line.
 */
function detectIndent(text: string, position: number): string {
  const lineStart = text.lastIndexOf('\n', position - 1) + 1;
  const match = text.slice(lineStart).match(/^(\s*)/);
  return match ? match[1] : '';
}

const HTML_MARKER = 'id="theme-fouc-prevention"';
const LAYOUT_MARKER = '<ThemeFOUCScript';

/**
 * Injects FOUC prevention script into the project's HTML or Next.js layout.
 * Shows a diff preview and asks for confirmation before writing.
 * Idempotent — skips if the marker already exists.
 * @param cwd - Project root directory.
 * @param project - Detected project metadata.
 * @returns Injection result status.
 */
export async function injectFOUCScript(
  cwd: string,
  project: IProjectInfo,
): Promise<FOUCResult> {
  if (project.framework === 'nextjs' && project.layoutFile) {
    return injectIntoNextLayout(cwd, project.layoutFile);
  }

  if (project.htmlEntryPoint) {
    return injectIntoHTML(cwd, project.htmlEntryPoint);
  }

  return 'no-entry-point';
}

/**
 * Injects inline FOUC script into an HTML file before `</head>`.
 * @param cwd - Project root directory.
 * @param htmlFile - Relative path to HTML entry (e.g. `index.html`).
 * @returns Injection result status.
 */
async function injectIntoHTML(cwd: string, htmlFile: string): Promise<FOUCResult> {
  const fullPath = join(cwd, htmlFile);
  const content = await readFile(fullPath, 'utf-8');

  if (content.includes(HTML_MARKER)) {
    return 'already-present';
  }

  const headCloseIndex = content.indexOf('</head>');
  if (headCloseIndex === -1) {
    return 'no-entry-point';
  }

  const script = generateFOUCScript({ storageType: 'localStorage', defaultTheme: 'default' });
  const scriptTag = `    <script ${HTML_MARKER}>${script}</script>\n  `;

  const before = content.slice(0, headCloseIndex);
  const after = content.slice(headCloseIndex);
  const updated = before + scriptTag + after;

  const changes: IFileChange[] = [
    { filePath: fullPath, oldContent: content, newContent: updated },
  ];

  const confirmed = await confirmChanges(changes);
  if (!confirmed) return 'declined';

  await writeFile(fullPath, updated, 'utf-8');
  return 'injected';
}

/**
 * Creates a standalone ThemeFOUCScript component and injects it into the Next.js layout.
 * Handles both layouts with explicit `<head>` and without (App Router default).
 * @param cwd - Project root directory.
 * @param layoutFile - Relative path to the layout file (e.g. `app/layout.tsx`).
 * @returns Injection result status.
 */
async function injectIntoNextLayout(cwd: string, layoutFile: string): Promise<FOUCResult> {
  const layoutPath = join(cwd, layoutFile);
  const content = await readFile(layoutPath, 'utf-8');

  if (content.includes(LAYOUT_MARKER)) {
    return 'already-present';
  }

  const layoutDir = dirname(layoutPath);
  const componentRelPath = join(layoutDir, 'theme-fouc-script.tsx');

  const script = generateFOUCScript({ storageType: 'cookie', defaultTheme: 'default' });
  const componentContent = `/**
 * FOUC prevention script component — auto-generated by theme-manager-init.
 * Renders an inline script that applies persisted theme/mode before first paint.
 */
export function ThemeFOUCScript() {
  return (
    <script
      id="theme-fouc-prevention"
      dangerouslySetInnerHTML={{ __html: ${JSON.stringify(script)} }}
    />
  );
}
`;

  const importLine = `import { ThemeFOUCScript } from './theme-fouc-script';\n`;
  const componentTag = `<ThemeFOUCScript />`;

  // Determine insertion point: <head> if present, otherwise add <head> before <body>
  const headMatch = content.match(/<head[^>]*>/);
  const bodyMatch = content.match(/<body[^>]*>/);

  if (!headMatch && !bodyMatch) {
    return 'no-entry-point';
  }

  // Step 1: Add import after last import line
  let updated: string;
  const hasImportSection = content.includes('import ');

  if (hasImportSection) {
    const lastImportIndex = content.lastIndexOf('\nimport ');
    const lineEnd = content.indexOf('\n', lastImportIndex + 1);
    updated = content.slice(0, lineEnd + 1) + importLine + content.slice(lineEnd + 1);
  } else {
    updated = importLine + content;
  }

  // Step 2: Insert component tag (detect indentation from surrounding JSX)
  if (headMatch) {
    const headTag = headMatch[0];
    const headIndex = updated.indexOf(headTag);
    const indent = detectIndent(updated, headIndex);
    const childIndent = indent + '  ';
    updated = updated.slice(0, headIndex + headTag.length)
      + `\n${childIndent}${componentTag}`
      + updated.slice(headIndex + headTag.length);
  } else {
    const bodyTag = bodyMatch![0];
    const bodyIndex = updated.indexOf(bodyTag);
    const indent = detectIndent(updated, bodyIndex);
    const childIndent = indent + '  ';
    // The slice before bodyIndex already contains the line's leading whitespace,
    // so <head> starts without extra indent; re-add indent before <body>.
    const headBlock = `<head>\n${childIndent}${componentTag}\n${indent}</head>\n${indent}`;
    updated = updated.slice(0, bodyIndex) + headBlock + updated.slice(bodyIndex);
  }

  // Preview all changes and ask for confirmation
  const changes: IFileChange[] = [
    { filePath: componentRelPath, oldContent: null, newContent: componentContent },
    { filePath: layoutPath, oldContent: content, newContent: updated },
  ];

  const confirmed = await confirmChanges(changes);
  if (!confirmed) return 'declined';

  await writeFile(componentRelPath, componentContent, 'utf-8');
  await writeFile(layoutPath, updated, 'utf-8');
  return 'injected';
}
