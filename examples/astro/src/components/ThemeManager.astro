---
// Server-side: Load themes directly from JSON file (no external fetching)
import fs from 'node:fs';
import path from 'node:path';

// Read registry.json directly from public folder
const registryPath = path.join(process.cwd(), 'public/themes/registry.json');
let availableThemes = [];

try {
  const registryContent = fs.readFileSync(registryPath, 'utf-8');
  const registry = JSON.parse(registryContent);
  availableThemes = registry.themes || [];
  console.log('‚úÖ Loaded', availableThemes.length, 'themes from registry');
} catch (error) {
  console.error('‚ùå Failed to load themes registry:', error);
  // Fallback themes
  availableThemes = [
    { id: 'default', label: 'Default', modes: { light: '/src/themes/default-light.css', dark: '/src/themes/default-dark.css' } },
    { id: 'supabase', label: 'Supabase', modes: { light: '/src/themes/supabase-light.css', dark: '/src/themes/supabase-dark.css' } },
    { id: 'tangerine', label: 'Tangerine', modes: { light: '/src/themes/tangerine-light.css', dark: '/src/themes/tangerine-dark.css' } }
  ];
}
---

<!-- Pass server data to client-side -->
<script type="module" define:vars={{ availableThemes }}>
  // Client-side logic with server data - no external imports
  const logger = {
    info: (msg, ...args) => console.log(`üé® [ThemeManager] ${msg}`, ...args),
    error: (msg, ...args) => console.error(`‚ùå [ThemeManager] ${msg}`, ...args),
    warn: (msg, ...args) => console.warn(`‚ö†Ô∏è [ThemeManager] ${msg}`, ...args)
  };
  let currentMode = 'auto';
  
  // Use passed server data
  const themes = availableThemes;
  
  console.log('üé® Available themes from server:', themes);

  async function initializeThemeSystem() {
    try {
      logger.info('üé® Initializing Theme System');
      
      // Load saved preferences
      const savedTheme = localStorage.getItem('theme') || 'default';
      const savedMode = localStorage.getItem('theme-mode') || 'auto';
      currentMode = savedMode;
      
      // Apply mode first
      applyMode(savedMode);
      
      // Apply saved theme immediately  
      applyThemeVariables(savedTheme);
      
      // Render theme list and bind events
      renderThemeList();
      bindEvents();
      setupModeToggle();
      updateUI(savedTheme, savedMode);
      
      logger.info('‚úÖ Theme System initialized successfully');
    } catch (error) {
      logger.error('‚ùå Failed to initialize Theme System:', error);
    }
  }

  function renderThemeList() {
    const themeList = document.getElementById('theme-list');
    if (!themeList) return;

    const currentTheme = localStorage.getItem('theme') || 'default';

    themeList.innerHTML = themes.map(theme => {
      const isActive = currentTheme === theme.id;
      const icon = getThemeIcon(theme.id);
      
      return `
        <button 
          type="button"
          class="theme-option relative flex w-full cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground"
          data-theme="${theme.id}"
          role="menuitem"
          ${isActive ? 'aria-selected="true"' : ''}
        >
          ${icon}
          <span>${theme.label}</span>
          ${isActive ? '<svg class="ml-auto h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>' : ''}
        </button>
      `;
    }).join('');
  }

  function bindEvents() {
    // Theme selection
    document.addEventListener('click', (e) => {
      const themeOption = e.target.closest('.theme-option');
      if (themeOption) {
        const themeName = themeOption.getAttribute('data-theme');
        if (themeName) selectTheme(themeName);
      }
    });

    // Browse more button
    const browseMoreBtn = document.getElementById('browse-more-themes');
    if (browseMoreBtn) {
      browseMoreBtn.addEventListener('click', () => {
        const modal = document.getElementById('theme-management-modal');
        if (modal) {
          modal.showModal();
          loadAvailableThemes();
        }
      });
    }
  }

  function setupModeToggle() {
    const modeToggle = document.getElementById('mode-toggle');
    if (modeToggle) {
      modeToggle.addEventListener('click', toggleMode);
    }
  }

  function selectTheme(themeName) {
    try {
      // Apply basic CSS variables based on theme
      applyThemeVariables(themeName);
      localStorage.setItem('theme', themeName);
      
      updateCurrentThemeLabel(themeName);
      renderThemeList();
      
      logger.info(`üé® Theme changed to: ${themeName}`);
    } catch (error) {
      logger.error('‚ùå Failed to set theme:', error);
    }
  }

  function applyThemeVariables(themeName) {
    // Apply theme CSS immediately
    const theme = themes.find(t => t.id === themeName);
    if (theme && theme.modes) {
      const mode = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
      const cssPath = theme.modes[mode];
      
      if (cssPath) {
        // Load CSS file dynamically
        loadThemeCSS(cssPath, themeName);
        logger.info(`üé® Applied theme: ${themeName} (${mode} mode)`);
      }
    }
  }

  function loadThemeCSS(cssPath, themeName) {
    // Remove existing theme CSS
    const existingLink = document.querySelector('link[data-theme]');
    if (existingLink) {
      existingLink.remove();
    }

    // Add new theme CSS
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = cssPath;
    link.dataset.theme = themeName;
    document.head.appendChild(link);
  }

  function toggleMode() {
    const modes = ['light', 'dark', 'auto'];
    const currentIndex = modes.indexOf(currentMode);
    const nextMode = modes[(currentIndex + 1) % modes.length];
    
    currentMode = nextMode;
    applyMode(nextMode);
    updateModeToggleIcon(nextMode);
    
    localStorage.setItem('theme-mode', nextMode);
    logger.info(`üåì Mode changed to: ${nextMode}`);
    
    // Re-apply theme with new mode
    const currentTheme = localStorage.getItem('theme') || 'default';
    applyThemeVariables(currentTheme);
  }

  function applyMode(mode) {
    let resolvedMode = mode;
    if (mode === 'auto') {
      resolvedMode = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    
    document.documentElement.setAttribute('data-mode', resolvedMode);
    document.documentElement.classList.toggle('dark', resolvedMode === 'dark');
  }

  function updateUI(themeName, mode) {
    updateCurrentThemeLabel(themeName);
    updateModeToggleIcon(mode);
  }

  function updateCurrentThemeLabel(themeName) {
    const label = document.getElementById('current-theme-label');
    if (label) {
      const theme = themes.find(t => t.id === themeName);
      label.textContent = theme?.label || themeName;
    }
  }

  function updateModeToggleIcon(mode) {
    const lightIcon = document.getElementById('light-icon');
    const darkIcon = document.getElementById('dark-icon');
    const autoIcon = document.getElementById('auto-icon');
    
    [lightIcon, darkIcon, autoIcon].forEach(icon => {
      if (icon) icon.classList.add('hidden');
    });
    
    const iconMap = { light: lightIcon, dark: darkIcon, auto: autoIcon };
    iconMap[mode]?.classList.remove('hidden');
  }

  function getThemeIcon(themeName) {
    const iconMap = {
      default: `<svg class="mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zM21 5H9a2 2 0 00-2 2v12a4 4 0 004 4h10a2 2 0 002-2V7a2 2 0 00-2-2z"></path></svg>`,
      supabase: `<svg class="mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7"></path></svg>`,
      tangerine: `<svg class="mr-2 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>`
    };
    return iconMap[themeName] || iconMap.default;
  }

  // Client-side ThemeListFetcher implementation
  class ThemeListFetcher {
    constructor() {
      this.REGISTRY_URL = 'https://tweakcn.com/r/registry.json';
      this.STORAGE_KEY = 'tweakcn-theme-names';
      this.LAST_FETCH_KEY = 'tweakcn-theme-fetch-timestamp';
      this.CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours
      this.cache = null;
    }

    getCachedThemeNames() {
      try {
        const cached = localStorage.getItem(this.STORAGE_KEY);
        return cached ? JSON.parse(cached) : [];
      } catch (error) {
        logger.error('Failed to parse cached theme names:', error);
        return [];
      }
    }

    async fetchAndCacheThemeNames(force = false) {
      try {
        // Check if we need to fetch
        if (!force && this.isCacheValid()) {
          const cached = this.getCachedThemeNames();
          if (cached.length > 0) {
            // Populate this.cache for compatibility
            if (!this.cache) {
              this.cache = {
                name: 'TweakCN Registry',
                homepage: 'https://tweakcn.com',
                items: cached.map(name => ({ name }))
              };
            }
            return cached;
          }
        }

        // Direct fetch to TweakCN registry
        const response = await fetch(this.REGISTRY_URL, {
          method: 'GET',
          mode: 'cors',
          headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) {
          throw new Error(`Registry fetch failed: ${response.status} ${response.statusText}`);
        }

        const registry = await response.json();
        
        if (!registry.items || !Array.isArray(registry.items)) {
          throw new Error('Invalid registry format: missing items array');
        }

        // Cache full registry for advanced methods
        this.cache = registry;

        // Extract only theme names for storage
        const themeNames = registry.items.map(item => item.name);

        // Store in localStorage
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(themeNames));
        localStorage.setItem(this.LAST_FETCH_KEY, Date.now().toString());

        return themeNames;

      } catch (error) {
        logger.error('ThemeListFetcher: Failed to fetch themes:', error);
        
        // Return cached data if available
        const cached = this.getCachedThemeNames();
        if (cached.length > 0) {
          return cached;
        }

        throw error;
      }
    }

    getThemeInstallUrl(themeName) {
      return `https://tweakcn.com/r/themes/${themeName}.json`;
    }

    async searchThemes(query) {
      const themes = await this.fetchAvailableThemes();
      const searchTerm = query.toLowerCase().trim();

      if (!searchTerm) return themes;

      return themes.filter(theme => 
        theme.name.toLowerCase().includes(searchTerm) ||
        (theme.description && theme.description.toLowerCase().includes(searchTerm))
      );
    }

    async fetchAvailableThemes() {
      // If we have cache, use it
      if (this.cache && this.cache.items) {
        return this.cache.items;
      }

      // Otherwise, fetch and populate cache
      await this.fetchAndCacheThemeNames();
      
      if (!this.cache || !this.cache.items) {
        logger.error('ThemeListFetcher: Cache still empty after fetch');
        return [];
      }
      
      return this.cache.items;
    }

    isCacheValid() {
      try {
        const lastFetch = localStorage.getItem(this.LAST_FETCH_KEY);
        if (!lastFetch) return false;
        
        const lastFetchTime = parseInt(lastFetch);
        return (Date.now() - lastFetchTime) < this.CACHE_DURATION;
      } catch (error) {
        return false;
      }
    }

    clearCache() {
      localStorage.removeItem(this.STORAGE_KEY);
      localStorage.removeItem(this.LAST_FETCH_KEY);
    }
  }

  // Create fetcher instance
  const themeListFetcher = new ThemeListFetcher();

  // Load available themes for browsing
  async function loadAvailableThemes() {
    const grid = document.getElementById('available-themes-grid');
    if (!grid) return;

    try {
      // Show loading state
      grid.innerHTML = `
        <div class="col-span-full flex items-center justify-center py-12 text-muted-foreground">
          <div class="text-center">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
            <p class="text-sm">Loading available themes...</p>
            <p class="text-xs mt-1">Fetching from TweakCN registry</p>
          </div>
        </div>
      `;

      const themeNames = await themeListFetcher.fetchAndCacheThemeNames();
      
      if (themeNames.length === 0) {
        grid.innerHTML = `
          <div class="col-span-full flex items-center justify-center py-12 text-muted-foreground">
            <div class="text-center">
              <p class="text-sm">No themes found</p>
              <p class="text-xs mt-1">Registry might be temporarily unavailable</p>
            </div>
          </div>
        `;
        return;
      }

      // Render theme grid
      grid.innerHTML = themeNames.map(themeName => {
        const displayName = formatThemeName(themeName);
        return `
          <div class="theme-card border rounded-lg p-3 hover:bg-accent/5 transition-colors">
            <div class="space-y-3">
              <div>
                <h4 class="font-medium text-sm">${displayName}</h4>
                <p class="text-xs text-muted-foreground font-mono">${themeName}</p>
              </div>
              <div class="flex gap-2">
                <button
                  type="button"
                  class="preview-theme-btn flex-1 text-xs border border-input bg-background hover:bg-accent hover:text-accent-foreground px-2 py-1 rounded transition-colors"
                  data-theme-name="${themeName}"
                >
                  Preview
                </button>
                <button
                  type="button"
                  class="install-theme-btn flex-1 text-xs bg-primary text-primary-foreground px-2 py-1 rounded hover:bg-primary/90 transition-colors"
                  data-theme-name="${themeName}"
                >
                  Install
                </button>
              </div>
            </div>
          </div>
        `;
      }).join('');

      // Bind events to new theme cards
      bindThemeCardEvents();
      
      logger.info(`‚úÖ Loaded ${themeNames.length} themes for browsing`);

    } catch (error) {
      logger.error('Failed to load available themes:', error);
      grid.innerHTML = `
        <div class="col-span-full flex items-center justify-center py-12 text-destructive">
          <div class="text-center">
            <p class="text-sm">Failed to load themes</p>
            <p class="text-xs mt-1">Check your internet connection</p>
          </div>
        </div>
      `;
    }
  }

  function bindThemeCardEvents() {
    // Preview buttons
    document.querySelectorAll('.preview-theme-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const themeName = e.target.getAttribute('data-theme-name');
        if (themeName) previewTheme(themeName);
      });
    });

    // Install buttons  
    document.querySelectorAll('.install-theme-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const themeName = e.target.getAttribute('data-theme-name');
        if (themeName) installThemeFromRegistry(themeName);
      });
    });
  }

  async function previewTheme(themeName) {
    logger.info(`üîç Previewing theme: ${themeName}`);
    // TODO: Implement theme preview functionality
  }

  async function installThemeFromRegistry(themeName) {
    try {
      logger.info(`‚¨áÔ∏è Installing theme: ${themeName}`);
      const installUrl = themeListFetcher.getThemeInstallUrl(themeName);
      
      // TODO: Implement theme installation
      logger.info(`üì¶ Theme install URL: ${installUrl}`);
      
    } catch (error) {
      logger.error('Failed to install theme:', error);
    }
  }

  function formatThemeName(name) {
    return name
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  // Search functionality
  function setupThemeSearch() {
    const searchInput = document.getElementById('theme-search-input');
    if (searchInput) {
      searchInput.addEventListener('input', async (e) => {
        const query = e.target.value;
        await searchAndRenderThemes(query);
      });
    }
  }

  async function searchAndRenderThemes(query) {
    const grid = document.getElementById('available-themes-grid');
    if (!grid) return;

    try {
      const themes = await themeListFetcher.searchThemes(query);
      const themeNames = themes.map(t => t.name);
      
      if (themeNames.length === 0) {
        grid.innerHTML = `
          <div class="col-span-full flex items-center justify-center py-12 text-muted-foreground">
            <div class="text-center">
              <p class="text-sm">No themes found for "${query}"</p>
              <p class="text-xs mt-1">Try a different search term</p>
            </div>
          </div>
        `;
        return;
      }

      // Re-render filtered results
      grid.innerHTML = themeNames.map(themeName => {
        const displayName = formatThemeName(themeName);
        return `
          <div class="theme-card border rounded-lg p-3 hover:bg-accent/5 transition-colors">
            <div class="space-y-3">
              <div>
                <h4 class="font-medium text-sm">${displayName}</h4>
                <p class="text-xs text-muted-foreground font-mono">${themeName}</p>
              </div>
              <div class="flex gap-2">
                <button
                  type="button" 
                  class="preview-theme-btn flex-1 text-xs border border-input bg-background hover:bg-accent hover:text-accent-foreground px-2 py-1 rounded transition-colors"
                  data-theme-name="${themeName}"
                >
                  Preview
                </button>
                <button
                  type="button"
                  class="install-theme-btn flex-1 text-xs bg-primary text-primary-foreground px-2 py-1 rounded hover:bg-primary/90 transition-colors" 
                  data-theme-name="${themeName}"
                >
                  Install
                </button>
              </div>
            </div>
          </div>
        `;
      }).join('');

      bindThemeCardEvents();
      
    } catch (error) {
      logger.error('Failed to search themes:', error);
    }
  }

  // Initialize on DOM load
  document.addEventListener('DOMContentLoaded', () => {
    initializeThemeSystem();
    setupThemeSearch();
  });
  
  // Re-initialize on Astro page transitions
  document.addEventListener('astro:page-load', () => {
    initializeThemeSystem();
    setupThemeSearch();
  });
</script>